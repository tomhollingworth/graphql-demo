package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.37

import (
	"context"
	"fmt"

	"github.com/tomhollingworth/graphql-demo/multiple-serve/influxdb-proxy/domain"
)

// FindEquipmentPropertyByID is the resolver for the findEquipmentPropertyByID field.
func (r *entityResolver) FindEquipmentPropertyByID(ctx context.Context, id string) (*domain.EquipmentProperty, error) {

	queryAPI := client.QueryAPI(org)
	// Get QueryTableResult

	q := `from(bucket:"` + bucket + `")
  |> range(start: -1d)
  |> filter(fn: (r) => r._measurement == "values")
  |> filter(fn: (r) => r.property == "` + id + `")
  |> pivot(rowKey:["_time"], columnKey: ["_field"], valueColumn: "_value")
`

	fmt.Println(q)
	result, err := queryAPI.Query(context.Background(), q)
	history := make([]*domain.History, 0)
	if err == nil {
		// Iterate over query response
		for result.Next() {
			// Notice when group key has changed
			if result.TableChanged() {
				fmt.Printf("table: %s\n", result.TableMetadata().String())
			}
			// Access data
			dt, ok := result.Record().ValueByKey("datatype").(string)
			if !ok {
				fmt.Printf("failed to parse datatype: %v\n", result.Record().ValueByKey("datatype"))
			}
			v := result.Record().ValueByKey("value")
			h := domain.History{
				EquipmentProperty: &domain.EquipmentProperty{
					ID: result.Record().ValueByKey("property").(string),
				},
				Datatype:  domain.DataType(dt),
				Value:     fmt.Sprintf("%v", v),
				Timestamp: result.Record().Time(),
			}
			history = append(history, &h)
		}
		// Check for an error
		if result.Err() != nil {
			fmt.Printf("query parsing error: %s\n", result.Err().Error())
		}
	} else {
		return nil, err
	}
	// Ensures background processes finishes
	client.Close()

	return &domain.EquipmentProperty{ID: id, History: history}, nil
}

// Entity returns EntityResolver implementation.
func (r *Resolver) Entity() EntityResolver { return &entityResolver{r} }

type entityResolver struct{ *Resolver }
