package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.37

import (
	"context"
	"database/sql"
	"fmt"

	"github.com/tomhollingworth/graphql-demo/multiple-serve/sql-proxy/graph/model"
)

// CreateEquipment is the resolver for the createEquipment field.
func (r *mutationResolver) CreateEquipment(ctx context.Context, input model.NewEquipment) (*model.Equipment, error) {
	res, err := db.Exec("INSERT INTO equipment (id, name, description) VALUES ($1, $2, $3)", input.ID, input.Name, input.Description)
	if err != nil {
		return nil, err
	}
	_, err = res.RowsAffected()
	if err != nil {
		return nil, err
	}
	rows, err := db.Query("SELECT id, name, description FROM equipment WHERE id = $1", input.ID)
	defer rows.Close()

	if err != nil {
		return nil, err
	}

	for rows.Next() {
		e := model.Equipment{}
		if err := rows.Scan(&e.ID, &e.Name, &e.Description); err != nil {
			fmt.Printf("failed to scan equipment row: %v\n", err)
			continue
		}
		return &e, nil
	}
	return nil, err
}

// CreateEquipmentProperty is the resolver for the createEquipmentProperty field.
func (r *mutationResolver) CreateEquipmentProperty(ctx context.Context, input model.NewEquipmentProperty) (*model.EquipmentProperty, error) {
	rows, err := db.Query("SELECT id, name, description FROM equipment WHERE id = $1", input.Equipment.ID)
	defer rows.Close()

	if err != nil {
		return nil, err
	}

	count := 0
	for rows.Next() {
		count += 1
	}

	if count == 0 {
		return nil, fmt.Errorf("equipment with id %s does not exist", input.Equipment.ID)
	}

	res, err := db.Exec("INSERT INTO equipment_property (id, description, equipment_id) VALUES ($1, $2, $3)", input.ID, input.Description, input.Equipment.ID)
	if err != nil {
		return nil, err
	}
	_, err = res.RowsAffected()
	if err != nil {
		return nil, err
	}
	rows, err = db.Query("SELECT id, description, equipment_id FROM equipment_property WHERE id = $1", input.ID)
	defer rows.Close()

	if err != nil {
		return nil, err
	}

	for rows.Next() {
		ep := model.EquipmentProperty{}
		e := &model.Equipment{}
		if err := rows.Scan(&ep.ID, &ep.Description, &e.ID); err != nil {
			fmt.Printf("failed to scan equipment_property row: %v\n", err)
			continue
		}
		ep.Equipment = e
		return &ep, nil
	}
	return nil, err
}

// DeleteEquipment is the resolver for the deleteEquipment field.
func (r *mutationResolver) DeleteEquipment(ctx context.Context, id string) (bool, error) {
	res, err := db.Exec("DELETE FROM equipment WHERE id = $1", id)
	if err != nil {
		return false, err
	}
	rows, err := res.RowsAffected()
	if err != nil {
		return false, err
	}
	return rows > 0, nil
}

// DeleteEquipmentProperty is the resolver for the deleteEquipmentProperty field.
func (r *mutationResolver) DeleteEquipmentProperty(ctx context.Context, id string) (bool, error) {
	res, err := db.Exec("DELETE FROM equipment_property WHERE id = $1", id)
	if err != nil {
		return false, err
	}
	rows, err := res.RowsAffected()
	if err != nil {
		return false, err
	}
	return rows > 0, nil
}

// Equipment is the resolver for the equipment field.
func (r *queryResolver) Equipment(ctx context.Context) ([]*model.Equipment, error) {
	rows, err := db.Query("SELECT id, name, description FROM equipment")
	defer rows.Close()

	if err != nil {
		return nil, err
	}

	result := make([]*model.Equipment, 0)
	for rows.Next() {
		e := model.Equipment{}
		if err := rows.Scan(&e.ID, &e.Name, &e.Description); err != nil {
			fmt.Printf("failed to scan equipment row: %v\n", err)
			continue
		}

		properties, err := r.EquipmentProperty(ctx, &model.FilterEquipmentProperty{Equipment: &model.EquipmentRef{ID: e.ID}})
		if err != nil {
			fmt.Printf("failed to scan equipment properties for row: %v\n", err)
			continue
		}
		e.Properties = properties

		result = append(result, &e)
	}
	return result, err
}

// EquipmentProperty is the resolver for the equipmentProperty field.
func (r *queryResolver) EquipmentProperty(ctx context.Context, filter *model.FilterEquipmentProperty) ([]*model.EquipmentProperty, error) {
	var rows *sql.Rows
	var err error
	if filter.Equipment == nil && filter.ID == nil {
		rows, err = db.Query("SELECT id, description, equipment_id FROM equipment_property")
	} else if filter.Equipment == nil && filter.ID != nil {
		rows, err = db.Query("SELECT id, description, equipment_id FROM equipment_property WHERE id = $1", *filter.ID)
	} else if filter.Equipment != nil && filter.ID == nil {
		rows, err = db.Query("SELECT id, description, equipment_id FROM equipment_property WHERE equipment_id = $1", *&filter.Equipment.ID)
	} else {
		rows, err = db.Query("SELECT id, description, equipment_id FROM equipment_property WHERE id = $1 and equipment_id = $2", *filter.ID, filter.Equipment.ID)
	}

	defer rows.Close()

	if err != nil {
		return nil, err
	}

	result := make([]*model.EquipmentProperty, 0)
	for rows.Next() {
		ep := model.EquipmentProperty{}
		e := &model.Equipment{}
		if err := rows.Scan(&ep.ID, &ep.Description, &e.ID); err != nil {
			fmt.Printf("failed to scan equipment_property row: %v\n", err)
			continue
		}
		ep.Equipment = e
		result = append(result, &ep)
	}
	return result, err
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
